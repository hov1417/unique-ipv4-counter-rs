#![feature(portable_simd)]

use std::ffi::OsString;
use std::fs::File;
use std::io;
use std::io::{BufWriter, Write};

fn calculate_hash(lens: [u8; 4]) -> u32 {
    let mut dot_mask = 0u128;
    let mut offset = 0u32;
    for len in lens {
        // TODO: rev ?
        offset += len as u32 + 1;
        dot_mask |= 1 << (offset - 1);
    }
    println!("{:b}", dot_mask);
    ((dot_mask >> 5) ^ (dot_mask & 0x03ff)) as u32
}

fn calculate_pattern(lens: [u8; 4]) -> Vec<u32> {
    let mut pattern = vec![255u32; 16];

    let mut offset = 0;
    for (index, &len) in lens.iter().enumerate() {
        if len >= 3 {
            pattern[8 + 2 * index] = offset;
            offset += 1;
        }
        if len >= 2 {
            pattern[2 * index] = offset;
            offset += 1;
        }
        if len >= 1 {
            pattern[2 * index + 1] = offset;
            offset += 1;
        }
        offset += 1;
    }

    pattern
}

fn main() -> io::Result<()> {
    println!("cargo::rerun-if-env-changed=BUILD_ACTION");
    let Some(action) = std::env::var_os("BUILD_ACTION") else {
        return Ok(());
    };
    if !action.eq(&OsString::from("GENERATE")) {
        return Ok(());
    }

    let mut shuffle = BufWriter::<File>::new(File::create("./src/shuffle_pattern.rs")?);

    let mut lookup1 = vec![81; 1229];
    let mut lookup2 = Vec::new();
    for i1 in 1..4 {
        for i2 in 1..4 {
            for i3 in 1..4 {
                for i4 in 1..4 {
                    let hash = calculate_hash([i1, i2, i3, i4]);
                    lookup1[hash as usize] = lookup2.len();
                    let pattern = calculate_pattern([i1, i2, i3, i4])
                        .iter()
                        .map(u32::to_string)
                        .collect::<Vec<_>>()
                        .join(", ");
                    lookup2.push(format!(
                        "/* {: <20}*/[{pattern}]",
                        pattern_template([i1, i2, i3, i4])
                    ));
                }
            }
        }
    }
    lookup2.push(format!("[{}]", vec!["0"; 16].join(", ")));

    shuffle.write_all(b"/* Code generated by build script; DO NOT EDIT */\n")?;
    shuffle.write_all(b"\npub static PATTERNS_ID: [u8; 1229] = [\n    ")?;
    shuffle.write_all(
        lookup1
            .iter()
            .map(usize::to_string)
            .collect::<Vec<_>>()
            .join(",\n    ")
            .as_bytes(),
    )?;
    shuffle.write_all(b"\n];\n")?;

    shuffle.write_all(b"\npub static PATTERNS: [[u8; 16]; 82] = [\n")?;

    shuffle.write_all(b"    ")?;
    shuffle.write_all(lookup2.join(",\n    ").as_bytes())?;
    shuffle.write_all(b"\n")?;

    shuffle.write_all(b"];\n")?;

    Ok(())
}

fn pattern_template(lens: [u8; 4]) -> String {
    format!(
        "{}.{}.{}.{}",
        "x".repeat(lens[0] as usize),
        "x".repeat(lens[1] as usize),
        "x".repeat(lens[2] as usize),
        "x".repeat(lens[3] as usize)
    )
}
